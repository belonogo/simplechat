#include <QApplication>
#include <QTreeWidget>
#include <QFile>
#include <QDomDocument>
#include <QUrl>
#include <QMap>
#include <QVector>

// Структура для хранения узлов дерева
struct TreeNode {
    QString url;
    QMap<QString, TreeNode*> children;

    TreeNode(const QString& url) : url(url) {}
};

// Рекурсивная функция для добавления URL в дерево
void addUrlToTree(TreeNode *root, const QStringList &pathParts) {
    if (pathParts.isEmpty()) {
        return;
    }

    QString currentPart = pathParts.first();
    QStringList remainingParts = pathParts.mid(1);

    if (!root->children.contains(currentPart)) {
        root->children[currentPart] = new TreeNode(currentPart);
    }

    addUrlToTree(root->children[currentPart], remainingParts);
}

// Функция для чтения XML и создания дерева ссылок
void parseXML(const QString &fileName, TreeNode *root) {
    QFile file(fileName);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        return;
    }

    QDomDocument doc;
    if (!doc.setContent(&file)) {
        file.close();
        return;
    }
    file.close();

    QDomNodeList urlNodes = doc.elementsByTagName("loc");
    for (int i = 0; i < urlNodes.count(); ++i) {
        QDomNode locNode = urlNodes.at(i);
        if (locNode.isElement()) {
            QString link = locNode.toElement().text();
            QUrl url(link);
            QStringList pathParts = url.path().split('/', Qt::SkipEmptyParts);
            addUrlToTree(root, pathParts);
        }
    }
}

// Рекурсивная функция для построения дерева в QTreeWidget
void buildTreeWidget(QTreeWidgetItem *parentItem, TreeNode *node) {
    for (auto child : node->children) {
        QTreeWidgetItem *childItem = new QTreeWidgetItem(parentItem);
        childItem->setText(0, child->url);
        buildTreeWidget(childItem, child);
    }
}

int main(int argc, char *argv[]) {
    QApplication a(argc, argv);

    // Создаем QTreeWidget для отображения дерева ссылок
    QTreeWidget treeWidget;
    treeWidget.setColumnCount(1);
    treeWidget.setHeaderLabel("Site Map");

    // Создаем корень дерева
    TreeNode root("Root");

    // Парсим XML файл и строим дерево ссылок
    parseXML("sitemap.xml", &root);

    // Добавляем дерево в QTreeWidget
    QTreeWidgetItem *rootItem = new QTreeWidgetItem(&treeWidget);
    rootItem->setText(0, root.url);
    buildTreeWidget(rootItem, &root);

    treeWidget.addTopLevelItem(rootItem);
    treeWidget.expandAll();

    treeWidget.show();
    return a.exec();
}





#include <QApplication>
#include <QTreeWidget>
#include <QFile>
#include <QDomDocument>
#include <QUrl>
#include <QMap>

// Функция для чтения XML и создания карты ссылок
void parseXML(const QString &fileName, QMap<QString, QStringList> &linkMap) {
    QFile file(fileName);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        return;
    }

    QDomDocument doc;
    if (!doc.setContent(&file)) {
        file.close();
        return;
    }
    file.close();

    QDomNodeList urlNodes = doc.elementsByTagName("url");
    for (int i = 0; i < urlNodes.count(); ++i) {
        QDomNode urlNode = urlNodes.at(i);
        if (urlNode.isElement()) {
            QDomElement locElement = urlNode.firstChildElement("loc");
            if (!locElement.isNull()) {
                QString link = locElement.text();
                QUrl url(link);
                QString host = url.host();
                QString path = url.path();

                // Добавляем в карту ссылок
                linkMap[host].append(path);
            }
        }
    }
}

// Функция для построения дерева ссылок в QTreeWidget
void buildLinkTree(QTreeWidget *treeWidget, const QMap<QString, QStringList> &linkMap) {
    QTreeWidgetItem *rootItem = new QTreeWidgetItem(treeWidget);
    rootItem->setText(0, "Root");

    for (const QString &host : linkMap.keys()) {
        QTreeWidgetItem *hostItem = new QTreeWidgetItem(rootItem);
        hostItem->setText(0, host);

        const QStringList &paths = linkMap[host];
        for (const QString &path : paths) {
            QTreeWidgetItem *pathItem = new QTreeWidgetItem(hostItem);
            pathItem->setText(0, path);
        }
    }

    treeWidget->addTopLevelItem(rootItem);
    treeWidget->expandAll();
}

int main(int argc, char *argv[]) {
    QApplication a(argc, argv);

    // Создаем QTreeWidget для отображения дерева ссылок
    QTreeWidget treeWidget;
    treeWidget.setColumnCount(1);
    treeWidget.setHeaderLabel("Site Map");

    // Парсим XML файл и строим карту ссылок
    QMap<QString, QStringList> linkMap;
    parseXML("sitemap.xml", linkMap);

    // Строим дерево ссылок в QTreeWidget
    buildLinkTree(&treeWidget, linkMap);

    treeWidget.show();
    return a.exec();
}






#include "encryption.h"
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <QDebug>

QByteArray Encryption::encryptData(const QByteArray &data, const QString &publicKey) {
    QByteArray encryptedData;

    BIO *keybio = BIO_new_mem_buf((void*)publicKey.toUtf8().data(), -1);
    RSA *rsa = PEM_read_bio_RSA_PUBKEY(keybio, nullptr, nullptr, nullptr);

    if (rsa == nullptr) {
        qDebug() << "Failed to create RSA structure";
        return encryptedData;
    }

    int rsaSize = RSA_size(rsa);
    encryptedData.resize(rsaSize);

    int result = RSA_public_encrypt(data.size(), (const unsigned char*)data.data(),
                                    (unsigned char*)encryptedData.data(), rsa, RSA_PKCS1_PADDING);

    if (result == -1) {
        qDebug() << "Encryption failed";
        encryptedData.clear();
    }

    RSA_free(rsa);
    BIO_free_all(keybio);

    return encryptedData;
}

QByteArray Encryption::decryptData(const QByteArray &encryptedData, const QString &privateKey) {
    QByteArray decryptedData;

    BIO *keybio = BIO_new_mem_buf((void*)privateKey.toUtf8().data(), -1);
    RSA *rsa = PEM_read_bio_RSAPrivateKey(keybio, nullptr, nullptr, nullptr);

    if (rsa == nullptr) {
        qDebug() << "Failed to create RSA structure";
        return decryptedData;
    }

    int rsaSize = RSA_size(rsa);
    decryptedData.resize(rsaSize);

    int result = RSA_private_decrypt(encryptedData.size(), (const unsigned char*)encryptedData.data(),
                                     (unsigned char*)decryptedData.data(), rsa, RSA_PKCS1_PADDING);

    if (result == -1) {
        qDebug() << "Decryption failed";
        decryptedData.clear();
    } else {
        decryptedData.resize(result);  // Убираем лишние байты
    }

    RSA_free(rsa);
    BIO_free_all(keybio);

    return decryptedData;
}

#ifndef ENCRYPTION_H
#define ENCRYPTION_H

#include <QByteArray>
#include <QString>

class Encryption {
public:
    static QByteArray encryptData(const QByteArray &data, const QString &publicKey);
    static QByteArray decryptData(const QByteArray &encryptedData, const QString &privateKey);
};

#endif // ENCRYPTION_H

